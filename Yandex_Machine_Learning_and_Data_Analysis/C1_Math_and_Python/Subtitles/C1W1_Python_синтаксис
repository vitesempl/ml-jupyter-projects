В этом видео мы познакомимся с типами данных в «Питоне». И начнем, конечно, с числовых типов данных. Допустим, нам нужно завести переменную, в которой будет некоторое целое число, ну, например, количество чего-нибудь. Ну это очень просто. Давайте ее выведем на печать теперь и посмотрим ее тип. Тип у нее int. С int-овыми переменными можно выполнять некоторые простые операции: складывать, умножать, делить. При этом, если результат сложения и умножения был действительно предсказуем, то результат деления может вас немного удивить. На самом деле, все достаточно логично. Если мы разделили int-овое число на int-овое число, то должны были получить тоже int, поэтому здесь деление целочисленное. Если мы попробуем поделить отрицательное число, то получим вот такой вот ответ. Если же вы хотите получить −1 в данном примере, то нужно взять деление 5 на 4 в скобки. Тогда сначала произойдет это деление, а потом уже будет умножение на −1. Кроме того, может быть, вам придется работать с достаточно большими числами. Большие числа будут, скорее всего, иметь тип long, но так как в «Питоне» динамическая типизация, и в одну переменную можно записать сначала один тип, потом другой, (вот давайте это проверим для нашего примера с большим числом), то можно особо не переживать из-за того, какой же там тип, int или long. Ну и, конечно, в «Питоне» есть дробные числа. Они представлены типом float. С ними тоже можно делать простые операции: сложение, умножение, деление. Ну и, конечно, здесь уже деление не целочисленное. И отсюда возникает идея: если вам нужно получить нецелочисленное деление, а аргументы у вас целые, то можно попробовать каждый аргумент привести к типу float. Но тогда получится действительно дробный результат. И при этом можно лишь один аргумент приводить к типу float, потому что в таком случае результат будет таким, чтобы вроде как ничего ценного не потерялось. Ну а раз один из аргументов — действительно дробное число, то, наверное, логично, что и результат должен быть дробным. Кроме того, в «Питоне» есть логический тип данных, bool, я его рассказываю вместе с числовыми, ну хотя бы потому, что bool легко можно привести к типу int, ну и потому, что если мы попробуем поскладывать разные значения, то мы получим вот такой вот интересный результат. То есть, оказывается, true + true будет равно двум. Ну, в самом деле, если мы приведем к int, то мы убедимся, что true это у нас единичка, а false это у нас 0. Кстати, обратите внимание, true и false в «Питоне» пишутся с большой буквы. Ну а здесь при сложении у нас сначала произошло неявное приведение к типу int. Ну и, конечно, есть обычные привычные операции с логическим типом. Это операция «и», «или». Давайте убедимся, что результаты такие, как обычно и продолжим дальше. В «Питоне» есть тип none. Это не 0 и не false. Это специальный тип, который означает отсутствие значения, у него даже свое название типа: NoneType. И его, конечно же, не получится привести к какому-то другому типу. Но как один из примеров того, откуда может взяться none, можно присвоить какой-нибудь переменный результат вычисления функций, которая ничего не возвращает. О функциях мы еще поговорим подробнее в следующем видео. Ну и, конечно, вы можете записывать переменные строки. Для этого есть тип str. С ним тоже есть какие-то простые операции, тоже можно складывать, но для строк сложение означает уже дописывание к одной строке другой строки. Можно приводить к нижнему регистру или к верхнему регистру. Можно получить длину строки. Можно привести к типу bool, если строка имеет не нулевую длину, то есть не пустая строка, то результат будет true. В противном случае, то есть для пустой строки, результат будет false. Ну и, конечно, приводить к числовому типу уже не получается. Можно получать различные элементы строки (ну вот здесь вот мы получили нулевой и первый элемент) или делать срез, то есть получать некоторый диапазон элементов. Смотрите, здесь мы сделали срез с нулевого по третий элемент. Третий элемент в итоге не включается. Ну и в срезе можно использовать еще один параметр. Это шаг. В этом случае мы получаем нулевой элемент, затем 0 + 2 получается элемент с индексом 2. Ну и 2 + 2 уже получается 4, а мы идем до 4 не включая. Вот поэтому получается такой результат. Есть еще один тип данных для строк, это unicode. Для этого вам нужно дописать перед строкой u. И вот, действительно, получается тип данных unicode. Но если вы знакомы с кодировками, то, конечно, вы понимаете, зачем может понадобиться этот тип данных. Ну, кроме того, любопытно, как переходить от типа unicode к типу str. Ну давайте объявим некоторую юникодную строку, посмотрим, что действительно она юникодная, и применим метод encode для того, чтобы получить str, и укажем кодировку utf8. Выведем на печать и увидим, что все хорошо. encode действительно делает из юникодной строки str. Ну а операция decode делает из str юникодную строку. При этом обратите внимание, если мы неверно укажем кодировку, ну, например, cp1251, которая, как правило, используется в Windows, то мы получим немного странный результат. Можно подумать, что можно было просто явно привести к типу str, но это неправда, действительно, ничего не срабатывает. Ну и на всякий случай, если вы не очень плотно знакомы с кодировками, давайте посмотрим, что будет, если мы в той строке, которая имеет тип str, возьмем срез с первого элемента. Вот смотрите, первая буква у нас почему-то сломалась. И, кстати, если мы посмотрим на длину строки, то для типа str она получилась одна, а для типа unicode другая. Дело вот в чем. Некоторые символы кодируются двумя байтами, некоторые — одним байтом. Тип данных unicode знает об этом, тип данных str не знает, и поэтому когда мы выводим длину для объекта типа str, то мы получаем несколько большее число, потому что некоторые буквы считались, получается, 2 раза. Ну и, кроме того, когда мы сделали decode с неправильной кодировкой, нам еще очень повезло. Ну вот смотрите. Допустим, у нас есть юникодная строка, вот мы сделали encode, получили str. Ну и теперь давайте попробуем сделать decode с правильной кодировкой. Все работает. А теперь попробуем сделать с неправильной. И, смотрите, в этом случае уже все сломалось. То есть просто та строка была более удачной для такого рода ошибки. Ну, как вы видите, бывают ситуации, когда мы получаем сообщение об ошибке, бывают ситуации, когда мы не получаем сообщение об ошибке и как-то неправильно декодируем. Конечно, это один из основных камней преткновения в выборе между вторым «Питоном» и третьим «Питоном», и многие сторонники третьего «Питона», в котором такой проблемы нет, и в котором один тип для строк, приводят это как аргумент в пользу третьего «Питона». Но на самом деле и за тот, и за другой аргументов много, и выбор — это скорее вопрос вкуса. Выбирайте то, что вам больше нравится, но мы продолжим для единообразия повествования на втором «Питоне». Итак. Давайте посмотрим еще на одну операцию. Это операция split. Она разбивает строчку по какой-то другой строке. Кстати, обратите внимание, я еще не делал замечания, но строки в «Питоне» можно писать как в двойных кавычках, так и в одинарных кавычках, и вот это достаточный результат. Теперь мы получили какой-то объект, который имеет тип, с которым мы до этого не сталкивались. Давайте посмотрим на его тип. Тип list. Забегая вперед, скажу, что это массив, и это не имеет никакого отношения к спискам из алгоритмов и структур данных. Ну и давайте попробуем сделать то же самое для русского текста. И увидим, что когда мы выводим массив с русскоязычными строчками, то мы получаем не очень читаемый вид. Давайте попробуем напечатать вот какой–то один фрагмент, видим, что это получается буква И. Вот, когда мы отсекли первый элемент, мы фактически попытались убрать вот эту часть, ну, действительно, получается что-то другое, ну а если мы делаем то же самое с юникодной строкой, то здесь уже кодируется немного по-другому. Ну раз уж мы столкнулись с массивом, давайте познакомимся с массивами. Одним из типов для массивов — это list. Ну что мы можем хранить в массивах? Мы можем хранить какие-то числа, ну, например, количество проданных товаров в разные дни, можем хранить какие-то строчки, например, уровень дохода разных людей, которые хотят взять кредит или брали когда-то кредит, или их имена. Ну и здесь мы опять получили какой-то не очень читаемый вывод, поэтому давайте воспользуемся методом join, который есть у строчек и позволяет просто соединить элементы массива какой-то другой строкой. Давайте посмотрим, что получится. Ну, если б мы взяли не пробел, а что-нибудь другое, то получилось бы вот так. Ну в дальнейшем, чтобы не заморачиваться с выводом, будем использовать английские символы, ну эта проблема, как вы видите, решается несложно. list позволяет хранить объекты разных типов. Зачем это может быть нужно? Ну, например, если вам нужно хранить описание опять-таки людей, которые брали когда-то кредиты, то у вас разные параметры могут иметь разные типы, ну, например, имя будет строковым параметром, время, на которое хочется взять кредит будет числом, а вернул или нет может быть булевским параметром. Ну и давайте посмотрим, как работает индексация. Индексация работает также как в строчках, мы действительно получаем элемент какой нужно по индексу, действительно можем делать срез также, как в строчках, можем делать срез до какого-то элемента или от какого то элемента, и можем использовать индексацию с конца массива. Также можем добавлять элемент массива с помощью метода append и удалять элементы. Кроме того, есть еще один тип данных для массивов — это тип данных tuple. Давайте его создадим, проверим, что работают те же операции среза, ну и попробуем добавить элементы. Здесь все закончилось не очень удачно, мы получили сообщение об ошибке, выяснили, что атрибута append вообще нет, и у нас, естественно, возникает вопрос: зачем же нужен такой массив, в который нельзя добавить новый элемент? Давайте продолжим и вскоре мы узнаем, зачем же нужен tuple. Итак, кроме того, в Python есть другие типы данных, а именно — множества и словари. Ну давайте начнем с множеств. Допустим, вы хотите создать переменную в которой будут храниться разные имена людей. Давайте убедимся что это set. Вот как вы видите в Python можно использовать не только квадратные скобки и круглые для объявления разных типов данных, но еще и фигурные, но и давайте посмотрим что получится, если мы проверим наличие какого-то элемента множеств. Вот мы получаем булевский ответ в зависимости от того, есть элемент или его нет. Можно элемент попробовать добавить и видеть, что все успешно, можно попробовать добавить тот элемент, который уже есть в множестве и увидеть, что конечно новый элемент не появился, потому что элемент уже есть, то есть дубликата множеств нет, можно удалять элементы. Можно попробовать добавить элемент какого-то другого типа по сравнению с теми, которые уже представлены. Это можно сделать с множеством точно также как с листом, но в примере, который мы сейчас запустим, ничего не получится, и мы получим сообщение об ошибке unhashable type list. Ну за такие алгоритмы и структур данных уже могли догадаться, что это связано с тем, что множество реализовано с помощью структур данных хеш-таблицы, и поэтому нужно, чтобы от добавляемого элемента можно было взять hash, то есть, чтобы элемент был неизменяемым, но если эти слова ничего для вас не говорят, достаточно просто запомнить, что изменяемые элементы добавлять в set нельзя. Но если мы попробуем добавить tuple, то всё получится удачно. Но можно подумать, зачем нам нужно множество? Могли бы просто содержать какой-то массив и поддерживать то, что в массиве не будет дубликатов, ну а если нужно, пробегаться по массиву и смотреть, есть ли там элементы. Но, конечно, это будет работать намного медленнее. Для этого попробуем сравнить ситуацию: создадим массив из чисел от нуля до десяти тысяч не включая и множество с числами от нуля до десяти тысяч не включая. Это можно сделать с помощью функции range. Ну давайте убедимся, что в массиве все что нужно, выведем первый элемент и последний, ну и теперь замерим время, за которое мы можем проверить, что какой-то элемент есть в массиве и есть множество. Разница колоссальная. Ну и кроме того, есть в Python тип данных dict — это словарь. Он пригодится нам, если нужно хранить какое-то отображение из одних элементов в другие, ну, например, для каждого слова уметь быстро получать его частоту в каком-нибудь тексте. При этом можно получать элемент по какому-то ключу и как выводить его на печать, так и обновлять значения. Ну и можно создавать множество, опять же, с помощью фигурных скобок, и можно хранить в множестве разные элементы и ключом, опять-таки, должен быть неизменяемый тип, ну то есть использовать tuple в качестве ключа можно, использовать list в качестве ключа — неудачная затея. Если Вам хочется познакомиться с Python еще более подробно или послушать другие изложения, то материала по Python очень много в Интернете, есть курсы на coursera, есть codeacademy, есть другие ресурсы, некоторые из этих ресурсов по третьему Python. Если Вам захочется ознакомиться и сравнить, можете ими воспользоваться.

[БЕЗ_ЗВУКА] В этом видео мы познакомимся с некоторыми простыми конструкциями языка «Питон» и начнем привыкать к его синтаксису. Итак, давайте разберемся с условным оператором. Точно так же, как и в других языках программирования, здесь можно написать что-нибудь в духе… там… давайте заведем какую-то переменную… напишем, пусть она равна true, и напишем if x… print… ok… Если мы хотим рассмотреть другой случай, то пишем else: и что-нибудь еще. Проверяем. Да, все хорошо. Если сейчас поменяем на false, все работает так, как нужно. Теперь обратите внимание, если во многих других языках программирования, когда мы пишем какую-то такую конструкцию, дальше тело следует в каких-нибудь скобочках, в «Питоне» для этого используются отступы. Отступы должны быть единообразными. Вот я здесь просто отступил на Tab, а если мы продолжаем тело, то нужно писать опять-таки тоже с отступом. Давайте еще что-нибудь напишем и посмотрим, что все хорошо, все работает. Ok. Теперь давайте разберемся с чем-нибудь еще. Ну, например, с циклами. Циклы встречаются, наверное, почти что в каждой программе. И давайте напишем простой цикл, в котором будем выводить числа от 1 до 10. For i in range (10), и опять же так же с отступом пишем print i. Давайте посмотрим, что получится. Ну смотрите. Вывелись числа 0, 1, ..., 9. То есть такая конструкция приводит к тому, что мы получаем все числа от 0 до 9 включая, то есть 10 не входит в этот интервал. При этом мы могли бы написать, ну, например, вот таким вот образом, и задать первое число. Тогда бы мы получили число от 1 до 9, и обратите внимание: когда мы делаем print, сразу же происходит перевод на следующую строку. Если мы хотим от этого избавиться, мы можем поставить здесь запятую, и тогда все это будет выведено через пробелы. Теперь давайте чуть подробнее изучим, что же такое range. Давайте просто сделаем print range от 2 до 5. Вот мы видим, что это просто какой-то список. И отсюда у нас возникает мысль, что может быть в «Питоне» можно писать каким-нибудь таким образом: for i in, давайте прям напишем список, print i. На самом деле так и есть, оказывается в «Питоне» циклы у нас устроены не таким образом, что мы обязательно в каком-то диапазоне значений пробегаемся, а мы просто пробегаемся по какому-нибудь контейнеру с элементами. Ну, например, по списку. То есть если мы возьмем и посмотрим type от range, то мы сразу же обнаружим, что это просто список. Сразу расскажу еще одну интересную вещь. Мы могли бы написать не range, а xrange, ну и то же самое, и увидеть, что результат абсолютно тот же. Возникает естественный вопрос — а зачем же нужно два способа добиться одного и того же результата? На самом деле результат не совсем один и тот же. Оказывается, если мы посмотрим тип xrange, то мы увидим, что xrange имеет тип xrange. Ну хорошо. Яснее нам не стало, но мы поняли, что это не список. Давайте еще напечатаем: xrange, [БЕЗ_ЗВУКА] ну, здесь мы видим чуть больше конкретики, но по прежнему остается некоторая загадка. Оказывается, xrange — это естественный пример генератора. А генератор не представляет из себя сразу готовый список различных значений, а генерирует их прямо на ходу. То есть у вас в памяти не хранится длинный список, как если вы напишите range и какое-то большое число. Ну вот, например, так. Если вы пишите for i in range от чего-то большого, то лучше всё же написать xrange. Так, давайте чуть подробнее познакомимся с генераторами, но для этого сначала мы изучим вещь, которая называется list comprehension. Оказывается, в «Питоне» очень многие вещи можно писать буквально в одну строчку. Ну, давайте попробуем вывести числа от 1 до 10 в массиве, и возведя их в квадрат. Можно просто взять написать print, квадратные скобочки, и в квадратных скобочках мы прямо пишем — x в квадрате for x in range 1 до 10 включительно, наверное, давайте выведем, так что 1, 11. Нажимаем и видим — да, действительно, результат. Ну, теперь давайте попробуем оставить из них только четные. Для этого достаточно дописать if x % 2 = 0. Дописываем, пожалуйста — остались только четные из них. Теперь давайте не будем это выводить на печать, а просто создадим объект, который будет равен вот этому всему. Сделали, теперь посмотрим тип. [БЕЗ_ЗВУКА] Ну, как мы видим, тип этого объекта — список, и здесь у нас возникает опять же вопрос — а как бы нам сделать не список, а генератор? То есть не хранить сразу все эти значения в памяти. Оказывается, для этого достаточно заменить квадратные скобочки на круглые, давайте посмотрим, что получилось. И вот, действительно, тип — генератор. Таким образом, range отличается от xrange ровно тем, чем в этом выражении отличаются квадратные скобочки от круглых. Ну, давайте теперь выясним, что у нас есть еще какие-то способы написать цикл. Ну, например, давайте скажем, что x = true, а while x, заведем какую-нибудь переменную, будем внутри цикла ее инкрементировать, и if s > 10, сделаем break, то есть завершим цикл. Ну и давайте всё это будем печатать. print s. Ну, оказывается, такой цикл тоже можно делать. В цикле, да, можно использовать break, можно использовать continue, которое приводит сразу же к переходу на следующею итерацию. Ну, давайте напишем так: if s % 2 = = 0, сделаем continue и посмотрим, как это отразится на выдаче. Угу-угу. Ну, вот мы видим, что вроде бы никак существенно не отразилось. Давайте попробуем понять, почему. [БЕЗ_ЗВУКА] Для этого попробую переставить в другое место. [БЕЗ_ЗВУКА] Ну и вот видите, мы получили нечаянно бесконечный цикл. Потому что мы просто проверяем, что остаток от деления на 2 равен нулю до того, как изменяем переменную s, и это условие у нас выполняется постоянно, и мы всё время делаем continue. Давайте проведем исполнение этого кода, вернем обратно. [БЕЗ_ЗВУКА] Ну? давайте, если это условие выполнилось, тоже что-нибудь напишем. Вот, смотрите. В этой ситуации мы получили следующий эффект. Мы просто делаем переход на следующую итерацию, в случае если s четное, и ничего не печатаем. Почему же в первый раз у нас получилось не совсем так? Ну просто вот это выражение у нас было написано после print s, поэтому вывод действительно не отличался. ну и давайте теперь познакомимся с функциями в Python, допустим, нам нужно реализовать, ну, например, свой range. Давайте напишем def myrange, пусть, опять же будут 2 переменные, a и b, от которых зависит результат, и также с отступом пишем return, и здесь напишем list comprehension, x for x in... ах, нет, тогда нам придется использовать range, наверное, это не очень хорошо. Давайте тогда просто создадим список, и напишем for... или даже так... while s не равно b, будем добавлять список с помощью метода append (s) и увеличивать s на единичку. Ну и давайте посмотрим, будет ли это все работать, и как. print myrange. Ну, вроде похоже на правду. Конечно, можно было бы еще подумать о каких-то особых ситуациях, когда мы будем давать не совсем подходящие числа на вход, но это не является нашей целью сейчас. Сейчас наша цель — просто познакомиться с синтаксисом. Синтаксис функций мы уже увидели. И давайте напоследок я расскажу еще об одной интересной вещи. Оказывается, нам необязательно писать что-то в духе x в квадрате for x in range (10), если мы хотим получить квадраты первых 10 чисел. Оказывается, тот же результат можно получить с помощью функции map. Функция map просто применяет некоторую функцию к контейнеру. Давайте опять напишем print map. Здесь напишем range (10), но какую функцию мы будем применять? Нам хочется возводить в квадрат, ну, давайте сразу определим функцию возведения в квадрат. [ПЕЧАТАЕТ] И ее и подставим в map. Ну да, так работает, но на самом деле есть еще одна удобная вещь, можно функции определять прямо на ходу с помощью так называемых λ-выражений. Ну, например, мы можем написать map точно так же написать range (10), а в качестве первого аргумента напишем следующую вещь: λ, дальше пишем переменную, x, дальше двоеточие, и пишем то, что нужно возвращать – x в квадрате. Посмотрим на результат. Да, все так, как нужно. Если нам нужно ввести функцию от нескольких переменных, то мы можем перечислить их здесь через запятую и использовать их. Каким-нибудь вот таким вот образом. Ну и здесь, конечно, этот код не заработает, потому что у нас подается на вход одна переменная. Итак, мы познакомились с основными конструкциями языка Python. В следующем видео вы узнаете о том, как читать из файла и как записывать файл.

На этом видео мы начнем говорить о работе с файлами в Python. Часто для анализа нам требуется использовать данные, хранящиеся в некотором внешнем файле. Это может быть электронная таблица, простой текстовый документ, html-документ — любой, доступный для хранения данных, формат. Для этого Python предоставляет нам целый ряд разнообразных инструментов. Мы с вами начнем с простого и изучим встроенную функцию open. Если вы встречаетесь с некоторой функцией в первый раз, то полезно почитать ее Docstring. Это делается с помощью вопросительного знака. Набираем вопросительный знак и имя функции — внизу экрана открывается Docstring. Мы можем увидеть, что функция принимает три аргумента: это name, mode и buffering. Нас будут интересовать первые два из них. Аргумент name отвечает за название файла, который мы хотим открыть. Если файл лежит в той же директории, что и IPython, то можно просто написать его имя. Если же он в другой директории, то придется прописать путь. Mode отвечает за то, каким образом мы хотим работать с файлом. Если мы не планируем делать никаких изменений, а, например, просто хотим прочитать содержимое файла или прочитать его в какой-то контейнер, то нам подойдет режим для чтения. В этом случае мы не сможем изменять сам файл, но тем не менее мы сможем его читать. Если мы хотим перезаписать существующий файл или записать новый, то нам нужен режим для записи. Если же мы хотим взять существующий файл и как-то его модифицировать, ну например добавить какие-то строчки в его конец, то нам подойдет режим append — режим для добавления данных в конец. Итак, мы с вами будем решать довольно простую задачу: мы возьмем файл, откроем его и выведем его содержимое на экран. Тогда нам подойдет режим для чтения. Итак, давайте зададим новый объект, назовем его file_object, и с помощью функции open откроем файл. [ПЕЧАТАЕТ] Далее, если мы хотим открывать файл в режиме для чтения, то нам необязательно указывать mode, потому что по умолчанию файл открывается в режиме для чтения. Но давайте мы его укажем, для того чтобы это было явно видно. Итак, мы создали наш объект, давайте теперь посмотрим, какой у него тип. Это делается с помощью команды type. Итак, мы видим, что тип нашего объекта действительно file. Теперь давайте выведем его на экран — это можно сделать с помощью функции read. [ПЕЧАТАЕТ] Мы видим, что наш файл состоит из трех строк, все эти строчки на русском языке. Часто нам бывает удобно считывать файл не полностью, а, например, считывать его по строкам. В частности, если у нас большой файл, нам бывает интересно просто почитать, как он начинается, прочесть несколько первых строк, а весь текст файла нам не нужен. В этом случае бывает удобно воспользоваться функцией readline. Для начала нам снова придется открыть файл для чтения. [ПЕЧАТАЕТ] [ПЕЧАТАЕТ] [ПЕЧАТАЕТ] А далее давайте вызовем функцию readline. [ПЕЧАТАЕТ] И видим, что у нас вывелась на экран только первая строка. А повторный вызов данной функции приведет к печати следующей строки. Давайте посмотрим. [ПЕЧАТАЕТ] Если продолжать процедуру, то мы таким образом можем дойти до конца файла. Вот вывод пустой строки на экран обозначает конец файла. Но, на самом деле, для того чтобы обращаться к файлу построчно, нам совсем необязательно пользоваться такими функциями, как read и readline — мы можем обращаться с файлом как с обычным генератором. Вот давайте посмотрим, как это выглядит. Снова откроем файл. [ПЕЧАТАЕТ] А дальше просто, с помощью цикла for, давайте этот файл обойдем и выведем на экран каждую его строчку. [ПЕЧАТАЕТ] [ПЕЧАТАЕТ] Обращаю внимание, что мы используем здесь новую функцию — это функция strip. Она помогает отрезать нам от конца каждой строки пробельные символы — это могут быть пробелы, знаки табуляции, а также знаки переноса строки. Итак, вызываем функцию и видим, что наш файл также напечатался построчно. Часто мы хотим работать со строчками файла как с массивом. Что имеется в виду? У нас есть файл, который состоит из нескольких строк, и мы хотим создать список, каждый элемент которого соответствует отдельной строке файла. Часто это бывает удобно. Это также можно сделать несколькими способами. Первый способ самый простой — изменить тип объекта file на список и просто работать с ним как со списком. Давайте это сделаем. Создадим объект data_list — список, и просто с помощью команды list сделаем наш файл объектом типа «список». Снова открываем файл для чтения. [ПЕЧАТАЕТ] И получаем наш список. Теперь давайте выведем содержимое списка на экран, чтобы убедиться, что каждый элемент соответствует отдельной строчке. [ПЕЧАТАЕТ] [ПЕЧАТАЕТ] [ПЕЧАТАЕТ] [ПЕЧАТАЕТ] Итак, видим, что результат снова нас удовлетворяет. Мы построчно вывели файл на экран. Второй способ — это использование функции readlines, она возвращает список строк нашего файла. [ПЕЧАТАЕТ] Уже привычным нам способом открываем файл. [ПЕЧАТАЕТ] И далее, с помощью функции readlines, создаем новый список. [ПЕЧАТАЕТ] [ПЕЧАТАЕТ] Итак, список готов, теперь снова давайте его напечатаем. [ПЕЧАТАЕТ] [ПЕЧАТАЕТ] Итак, готово. Соответственно, теперь вы можете выбирать тот способ, который вам больше нравится: использование функции readlines или просто работа с файлом как со списком. Когда мы закончили работу с файлом, файл нужно закрыть. Это делается с помощью команды close. Это полезно сразу по нескольким причинам. Первая причина — мы освобождаем ресурсы, которые используются системой на чтение и поддержку нашего файла. Вторая причина — это так называемая безопасная работа с файлом. После того как мы файл закрыли, мы уже не можем его читать, не можем вносить в него изменения. Таким образом, наш файл в какой-то степени защищен от каких-то незапланированных действий или ошибок. Давайте посмотрим, как это работает. Если мы сначала открыли файл, например, открываем его снова для чтения. Возьмем тот же самый файл. Дальше мы вызвали функцию, которая его закрывает — функция close. [ПЕЧАТАЕТ] И дальше, например, давайте попробуем его прочесть, после того как мы его закрыли. Это должно привести к ошибке, потому что мы пытаемся прочитать уже закрытый файл. И действительно, мы видим, что операция такая невозможна, потому что мы пытаемся прочитать закрытый файл. Итак, мы с вами уже научились читать файл и делать это несколькими способами. На самом деле, все это время мы работали с файлом в кодировке utf8, это можно было понять из названия. В жизни это не всегда так, и часто нам приходится работать с данными в разных кодировках. Давайте теперь попробуем открыть файл в кодировке koi_8-r — это русскоязычная кириллица. Для начала попробуем поступить аналогичным образом. Используем функцию open. Создаем объект file и пытаемся прочитать его, после чего — вывести его на экран. [ПЕЧАТАЕТ] Теперь вызываем метод read. [ПЕЧАТАЕТ] И видим, что наш файл выглядит не совсем так, как нам хотелось. Давайте добавим функцию print и убедимся в этом. Вот видите, появились какие-то не очень симпатичные символы. Это говорит о том, что у нас есть проблемы с этой кодировкой. Для того чтобы напечатать этот файл красиво, нужно каким-то образом указать, что мы используем кодировку utf8. Ну на самом деле, сделать это можно разными способами. Один из самых простых — это использовать библиотеку Codecs. Давайте на нее посмотрим. [ПЕЧАТАЕТ] Для начала ее нужно импортировать. Это делается с помощью ключевого слова import. [ПЕЧАТАЕТ] А теперь давайте читать файл. На самом деле, библиотека Codecs предоставляет нам похожую функцию open. У нее схожий синтаксис, только нам можно указать еще дополнительные параметры, например кодировку. Вот давайте это сделаем. Снова создадим объект file, назовем его file_object. И теперь уже с помощью функции open из модуля Codecs будем его читать. Передаем туда название файла. И теперь давайте добавим новый параметр encoding, или кодировка. [ПЕЧАТАЕТ] Так, файл мы прочли. Теперь давайте выведем его на экран, ожидая, что теперь у нас не будет проблем с выводом. [ПЕЧАТАЕТ] Итак, мы видим, что теперь файл выводится корректно. Это происходит, потому что мы открыли его в правильной кодировке. На этом мы заканчиваем знакомство с чтением данных. На следующем видео мы также будем говорить про работу с файлами, но уже будем учиться файл записывать.

В этом видео мы продолжим говорить о работе с файлами в Python. В прошлый раз мы научились читать данные с файлов, теперь давайте учиться их в файл записывать. Это часто бывает полезно, особенно если хочется сохранить результаты вашей работы для дальнейшего анализа. Итак, мы уже знаем, что открывать файлы можно с помощью функции open из стандартной библиотеки или из библиотеки codecs. Ну давайте продолжим работать со встроенной функцией и откроем файл для записи. В этот раз мы будем решать следующую задачу. Создадим несколько текстовых строк и запишем их в файл. Для начала снова открываем файл, в этот раз для записи. [ЗВУК] Ну давайте назовем его как-нибудь просто: file_to_write_in — файл для записи. И указываем режим w, режим writing. Так, дальше нам нужно создать строчку, которую мы в файл будем записывать. Ну давайте просто напишем: строка для записи в файл. В конец строки не забываем добавить символ переноса строки. Он нужен для того, чтобы в случае, если мы записываем файл сразу в несколько строк, они бы не склеились в одну, а шли одна за другой. Так читать гораздо приятней. Дальше с помощью функции write записываем эту строчку в наш файл. [ЗВУК] И дальше не забываем закрыть файл. Давайте это запустим. Так, забыли скобочки. Теперь запустим еще раз. И теперь давайте посмотрим, как выглядит наш файл. Для этого можно использовать команду bash cat. [ЗВУК] Видим, что наш файл выглядит ровно так, как мы с вами и хотели. Та самая строчка, которую мы в него записывали, выведена на экран. Теперь давайте повторим процесс. Допустим, нам хочется записать еще одну строчку в этот файл. Казалось бы, нужно действовать аналогичным образом. Снова открыть файл для записи, записать строчку и вывести файл на экран. Давайте попробуем. Открываем файл. [ЗВУК] Ну давайте теперь создадим какую-нибудь новую строчку. Ну давайте напишем: вторая строка для записи в файл. [ЗВУК] Снова не забываем про символы переноса строки. Далее вызываем у файла метод write, записываем строчку. [ЗВУК] И закрываем наш файл. Так. Поправим имя функции. И сделаем это еще раз. Итак, давайте выведем файл на экран и посмотрим, как он выглядит. [ЗВУК] Что мы видим? Наша первая строка исчезла, зато в файле появилась вторая строка. Это произошло из-за того, что мы перезаписали наш старый файл новым. Так происходит, когда мы работаем с файлами в режиме write. Если файл уже существует в данной директории, то он будет перезаписан новым файлом. А если бы файла с таким названием еще не было, то мы бы действительно создали новый файл, как в первый раз. Теперь давайте все-таки сделаем правильно, мы с вами хотим добавить строчку в конец существующего файла, а не переписать его заново. Для этого нам просто нужно использовать другой режим. Это режим append, или режим добавления. Давайте снова откроем файл. [ЗВУК] Только теперь не забудем указать правильный режим. Создадим новую строчку. Ну напишем: третья строка для записи в файл. [ЗВУК] И с помощью уже знакомой нам функции write запишем эту строчку в файл. [ЗВУК] [ЗВУК] Так. Теперь давайте посмотрим, что у нас получилось. Мы ожидаем увидеть две строки. Итак, действительно. В нашем файле появилась вторая и третья строка. На самом деле, часто мы хотим записать сразу много строк в файл. У нас может быть целый список строк для записи. Мы можем делать это разными способами. Но самое простое — это просто в цикле записать все эти строчки с помощью функции write. Мы можем поступить по-другому. Для этого существует специальная функция writelines, которая принимает в качестве аргумента список строк для записи в файл. Давайте продемонстрируем ее работу. Для начала нам с вами нужно создать этот список строк. Ну давайте сделаем что-нибудь простое. Допустим, запишем в файл числа от 1 до 10. Для этого сначала создаем массив этих чисел. Назовем его digits. Сделаем это с помощью функции range. Вот давайте выведем его на экран. Итак, мы видим, что это простые числа. Теперь нужно их записать. Но тут есть два нюанса. Во-первых, файл мы можем записывать только в строчки, поэтому сначала нам нужно изменить тип нашего массива и сделать его массивом строк. Второй нюанс следующий: если мы запишем эти строки как есть, то они у нас при записи склеятся в одно значение. Ну потому что у нас нет символов перевода строки. Поэтому перед записью нам с вами нужно не забыть эти символы добавить в конец каждой строки. Итак. Теперь снова открываем файл для записи. Давайте сделаем это немножечко по-другому. Будем использовать ключевое слово with. Это довольно удобно, потому что в этом случае нам не нужно беспокоиться о закрытии файла. Мы можем быть уверены, что при выходе из блока with файл будет закрыт. Итак, набираем это ключевое слово, дальше открываем файл для записи, как обычно, с помощью функции open. Ну давайте запишем данные на этот раз в другой файл, назовем его «второй файл для записи». [ЗВУК] [ЗВУК] Дальше сразу же начинаем писать с помощью функции writelines. Не забываем, что ей нужно передать массив. Но мы хотим с ним сделать дополнительные действия. Для начала давайте добавим символы перевода строки. Это символы слэша. А теперь с помощью функции map давайте изменим тип нашего массива. [ЗВУК] Итак, мы закончили, теперь можем запускать. Теперь давайте посмотрим, как выглядит наш файл. [ЗВУК] Итак, он ровно такой, как нам бы и хотелось. Десять строк по одному числу в каждой строчке. Итак, на этом мы с вами заканчиваем работу с файлами. Теперь вы умеете работать с файлами в различных кодировках, можете читать данные, можете их записывать. А в следующем видео мы начнем знакомство с библиотекой Pandas. Она также позволяет нам гибко работать с файлами, в частности она позволяет нам работать с файлами в виде таблиц. Это довольно удобно для задачи анализа данных.