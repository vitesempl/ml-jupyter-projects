[БЕЗ_ЗВУКА] Мы начинаем урок, посвященный матрицам. В нём мы поговорим о том, как они определяются, как вводить операции на них и как изучать их свойства. В первом видео поговорим об определении матриц. Давайте вспомним примеры задач, которые мы рассматривали раньше. Пусть есть некоторые бутылки вина, для каждой из которых мы хотим определить, из какого сорта винограда она сделана. Это может быть нужно, чтобы отличать и настоящие бутылки от подделок: те, которые сделаны из дорогого сорта винограда от тех, которые сделаны из непонятно чего. Данные про эти бутылки имеют двумерную структуру. Дело в том, что бутылок много, и каждая из них описывается набором чисел, или признаками, числовыми характеристиками этих бутылок. Такие двумерные структуры встречаются постоянно, поэтому нужно как-то их характеризовать. Они называются матрицами. Матрицы — это, по сути, таблица с числами. Они обычно обозначаются большими буквами, например A. Элементы же матрицы A большое обознаются буквами a малое с двумя нижними индексами: первый обозначает номер строки, второй — номер столбца. Например, a₁₂ — это элемент матрицы A в первой строке, втором столбце. В нашем примере это 7. a₃₁ — это элемент матрицы A в третьей строке и первом столбце. У нас это −3. Наша матрица имеет размер 4 на 5, то есть это четыре бутылки вина, каждая из которых характеризуется пятью признаками. Пространство всех таких матриц будем обозначать как красивую букву R с верхним индексом 4 умножить на 5. Зачем нужны матрицы? Например, они используются для работы с системами линейных уравнений. Представьте, что у нас есть четыре бутылки вина, и для каждой из них мы знаем, подлинная они или нет, сделана из правильного сорта винограда или из ка... из какого-то дешевого — это подделка. Можно закодировать это с помощью вектора. Например, если первая и четвертая бутылки подлинные, а вторая и третья — это подделки, то закодируем это вектором y с элементами 1, 0, 0 и 1, где 1 — это подлинность, 0 — это подделка. Мы можем потребовать следующее: будем производить линейную классификацию, то есть будем складывать значение всех признаков с некоторыми весами, которые мы обозначаем как w₁, w₂, w₃, w₄ и w₅, и будем требовать, чтобы такая взвешенная сумма равнялась номеру класса, то есть 1, если бутылка подлинная, 0, если это подделка. Получаем следующую систему уравнений. У неё могут быть некоторые проблемы. Например, она может быть неразрешима или, наоборот, у нее может быть слишком много решений, но с этим будем разбираться позже, в курсах на машинное обучение. А пока будем рассматривать именно такую систему уравнений. Они будут встречаться постоянно в нашем курсе в самых разных задачах. И оказывается, можно очень удобно и лаконично записать такую систему, используя векторы и матрицы. При этом решения таких систем также будут выражаться через векторы и матрицы. Но сначала разберемся с парой нюансов, а именно: давайте заметим, что вектор размера n — это, по сути, тоже матрица, у которой одна из размерностей равна 1. При этом вектор может быть как вектор-столбцом, то есть матрицей размера n на 1, так и вектором-строкой, то есть матрицей размера 1 на n. Давайте введём операцию умножения матрицы размера m на n на вектор-столбец размера n. Как это делается? Результатом умножения такой матрицы на такой вектор будет новый вектор длины m. При этом первый элемент этого вектора вычисляется как произведение каждого элемента первой строки матрицы A на каждый элемент вектора w, и потом это суммируется. Аналогично вторая.... второй элемент этого вектора — это произведение второй строки матрицы A на вектор w и затем снова суммирование, и так далее. Благодаря этому мы сможем матрично записать нашу систему линейных уравнений. Она будет выглядеть как A умножить на w равняется y — всё очень просто и кратко. Давайте потренируемся умножать матрицы на векторы. Умножим нашу матрицу признаков A на вектор весов с координатами 1, 2, 1, 0, 0. Найдем первый элемент их произведения. Он получается умножением первой строки матрицы на этот вектор, то есть 12 умножить на 1, плюс 2 умножить на 7, плюс 1 умножить на 21, плюс 0 умножить на 31, плюс 0 умножить на 11, или 47. Второй элемент вектора будет равен 55, третий — 63 и последний — 33. Давайте заметим ещё один момент. Пусть есть некоторая матрица размера m на n. Умножая её на некоторый вектор длины n, мы получаем на выходе вектор длины m. В нашем случае из длины... из вектора длины 5 мы получили вектор длины 4. Получается, что матрица задаёт некоторое преобразование, некоторую функцию: из одного векторного пространства размерности n в другое векторное пространство размерности m. Они будут часто возникать у нас. Кстати, такие преобразования называются линейными. Итак, что мы узнали? Матрицы — это, по сути, таблицы с числами, при этом вектор тоже является матрицей, у которой одна из размерностей равна 1. Через матрицы можно записывать системы линейных уравнений. Также матрицы задают линейные преобразования, или функции, из одних векторных пространств в другие. В следующем видео мы более подробно поговорим об умножении матриц на матрицу или матрицы на векторы и введём другие матричные операции.

[БЕЗ_ЗВУКА] В это видео мы поговорим о том, какие операции можно вводить над матрицами. В прошлый раз мы уже разобрались с вами, как умножать матрицу на вектор. А именно: мы можем умножать матрицу размера m × n на вектор-столбец размера n × 1. Для этого мы домножаем каждый элемент i-той строки на соответствующий элемент вектора и складываем. В итоге получаем i-тый элемент вектора-результата. Получаем мы на выходе вектор размера m × 1. Обратите внимание, мы могли умножать матрицу на вектор только в том случае, если число столбцов в матрице совпадало с длиной вектора. Иначе операция была не определена. Давайте теперь поговорим о том, как ввести более общую операцию — умножение матрицы на матрицу. Она будет возможна только в том случае, если число столбцов в первой матрице совпадает с числом строк во второй матрице. Иначе эта операция будет не определена, делать её будет невозможно. Итак. Пусть есть две матрицы — A и B. Матрица A имеет размер m × n, а матрица B имеет размер n × k. Результатом будет матрица C размера m × k. То есть строк в ней будет столько же, сколько в первой матрице, а столбцов столько же, сколько во второй. Чтобы перемножить матрицы A и B и получить C, мы делаем следующее: i-тый j-тый элемент матрицы C получается поэлементным умножением i-той строки матрицы A на j-тый столбец матрицы B, что затем складывается. Именно так и получается матрица C. Давайте разберём пример. Пусть есть две матрицы, первая имеет размер 3 × 2, вторая 2 × 3. Результатом будет матрица размера 3 × 3. Давайте получим её элемент с индексами 1, 1. Для этого нам понадобится первая строка матрицы A и первый столбец матрицы B. Перемножаем их. Получаем 1 * 1 + 2 * 0. Значит, элемент с индексами 1, 1 матрицы C будет равен 1. Посчитаем элемент с индексами 1, 2. Для этого мы умножаем 1 на 0 и 2 на 0 и складываем. Получаем 0. Чтобы получить элемент с индексами 1, 3, умножаем 1 на 0, прибавляем 2 * 2, получаем 4. Наконец, чтобы получить элемент с индексом 2, 1, умножаем 0 на 1, 1 на 0, получаем 0. И так далее. У вас, наверное, уже возник вопрос: почему мы ввели операцию умножения матриц именно так? Эта формула не кажется интуитивной, она не приходит в голову в первую очередь. Но, оказывается, у неё есть довольно понятный глубокий смысл. Давайте попробуем его понять. Мы уже выясняли, что матрица, по сути, задаёт линейное преобразование, линейную функцию из одного векторного пространства в другое. То есть, по сути, она принимает на вход один вектор и возвращает другой, уже другой разрядности. Например, матрица A может задавать преобразование из пространства V в пространство W, а матрица B — задавать преобразование из пространства W в пространство T. Поскольку это функции, можем определить их композицию, B от A, то есть сначала к вектору из пространства V применяем преобразование A, потом преобразование B, и в итоге вектор из пространства V переходит в пространство T. При этом оказывается, если мы перемножим матрицы B и A, то полученное произведение BA будет как раз задавать преобразование из пространства V в пространство T, ровно то преобразование, которое является композицией B и A. Это одна из главных причин, почему умножение вводится именно так. Есть ещё одна причина. Представьте, что у нас есть некоторая система линейных уравнений Ax = b. Например, это может быть задача поиска линейного классификатора для предсказания возникновения рака. В этом случае в строках A записаны пациенты, для каждого пациента известно, какие мутации имеют место в его геноме, а в B записан правильный ответ: возникнет рак через 5 лет или не возникнет. Тогда x — это веса, с которыми складываются индикаторы наличия мутации в геноме, и получается некоторый ответ. При этом, на самом деле, x может тоже выражаться через другой вектор z, то есть может иметь место уравнение x = Bz. Откуда оно может быть? Оно может задавать некоторые дополнительные ограничения. Например, что две определённые мутации должны носить одинаковый вклад в принятие решения, то есть должны иметь одинаковый вес. Это всё можно отрегулировать матрицей B. В итоге получается, что нужно решать систему вида A*(Bz) = b. Так вот. Оказывается, что если мы поставим выражение для вектора x, то есть x = Bz, в первое уравнение, раскроем скобки, сгруппируем и получим уравнение относительно z, то мы получим систему с матрицей, которая будет равняться произведению A и B. То есть мы ввели умножение так, чтоб можно было подставлять одну систему линейных уравнений в другую, и при этом всё сохранялось. Хорошо. Давайте поговорим о более простых операциях — сложение и умножение на число. Здесь всё гораздо более интуитивно. Чтобы сложить две матрицы, мы должны убедиться, что они имеют одинаковый размер. То есть обе имеют размерность m × n, иначе сложение не определено. Складываем мы поэлементно. То есть i-тый j-тый элемент матрицы C суммы A и B будет равняться aij + bij. Всё очень просто. То же самое касается умножения на число. Чтобы умножить матрицу b на некоторое число α, просто умножаем на α каждый элемент. То есть cij — результат — будет равен α * bij. Наконец, поговорим о такой операции, как транспонирование. Мы будем с ней сталкиваться довольно часто. Для этого нам понадобится понятие главной диагонали. Пусть есть некая матрица A размера 4 × 3. Главной диагональю называются все её элементы, у которых первый индекс равен второму, то есть все элементы вида aii. В нашем случае, это будет элемент (1, 1), (2, 2) и (3, 3), которые имеют значения 1, 3 и 0. Это действительно диагональ. Транспонирование — это, по сути, поворот относительно главной диагонали. Матрица A размера m × n превращается в матрицу A транспонированное размера n × m. Кстати, A транспонированное обозначается как A с верхним индексом T. Иными словами, i-тый j-тый элемент транспонированной матрицы равен j-тому i-тому элементу исходной матрицы. Ещё можно интерпретировать это так, что строки исходной матрицы становятся столбцами транспонированной матрицы. Вернёмся к нашему примеру. Матрица размера 4 × 3 становится матрицей 3 × 4, при этом главная диагональ 1, 3, 0 остаётся на своём месте, а всё остальное поворачивается относительно неё. То есть, например, столбец 1, 2, 2 ,5 (первый столбец) становится первой строкой 1, 2, 2, 5. И так далее. Итак. Что мы узнали? Умножение матриц — это довольно хитрая операция, которая при этом имеет довольно глубокий смысл. Например, она соответствует композиции двух линейных преобразований или соответствует постановке в систему линейных уравнений вектора, который тоже выражается как матрица умножить на вектор. При этом сложение и умножение для матриц (умножение на константу) определяется интуитивно, просто поэлементно. Также мы изучили с вами транспонирование — это операция, которая меняет строки и столбцы матрицы местами. В следующем видео мы поговорим о том, что такое ранг и определитель.

В этом видео мы узнаем, что такое ранг и определитель. Рассмотрим пример. Пусть есть два вектора. У первого координаты (1, 2), у второго координаты (3, 1). Их можно дополнить до параллелепипеда, получив при этом замкнутую фигуру. И вот можно задаться вопросом: а какая площадь у этой фигуры? Ну, можно смотреть формулу из школы, но при этом есть более простые способы. Давайте составим матрицу, которая состоит из двух строк и двух столбцов, и запишем в неё координаты векторов. Первая строка матрицы будет иметь вид 1, 2, вторая — 3, 1. Оказывается, что площадь параллелепипеда равна определителю этой матрицы, который для матрицы размера 2 на 2 задаётся как a₁₁ * a₂₂ − a₁₂ * a₂₁ и обозначается как модуль A, или как det A (от слова детерминант, это другое название определителя). Можно посчитать, что в нашем случае эта формула даст (−5). 5 — это правильный ответ, но почему есть знак? Оказывается, определитель выставляет знак площади в зависимости от ориентации векторов относительно друг друга. Если первый вектор идёт против часовой стрелки от второго, то знак будет положительный, иначе — отрицательный. Итак, немного подробнее про определитель. Его можно задать только для квадратной матрицы, иначе он не определён. Есть много способов сказать, что это такое. Один из них — это объём параллелограмма, построенного из n векторов по строкам или столбцам этой матрицы. Если же говорить о более алгебраических способах задания определителя, то один из них, например, позволяет задать определитель матрицы размера n на n через некоторую взвешенную сумму определителей матриц размера n − 1 на n − 1. Мы не будем вдаваться в подробности, но если вам будет интересно, почитайте про теорему Гаусса. Давайте перейдём к другому примеру. У нас были векторы с координатами (1, 2) и (3, 1), и они были линейно независимы. А что если это будут другие два вектора, с координатами (3, 1) и (6, 2)? Они будут параллельны, они будут линейно зависимы. Обратите внимание, что при этом площадь параллелограмма, построенного на них, будет равна нулю. Это важное замечание. Если вектор линейно зависимый, то площадь — ноль, если независимый — то площадь не ноль. Оказывается, это довольно общий закон. В терминах определителя он формулируется следующим образом: определитель равен нулю тогда и только тогда, когда строки матрицы линейно зависимы. То же самое можно сказать про столбцы: определитель равен нулю тогда и только тогда, когда столбцы матрицы линейно зависимы. Это довольно важное свойство. Есть и другие свойства. Например, определитель матрицы A транспонированная совпадает с определителем матрицы A. Или определитель матрицы A * B равен произведению определителей матрицы A и матрицы B. Давайте дадим другое определение, которое расположено примерно в той же области линейной алгебры, где и определитель. А именно — ранг матрицы. Это определение состоит из двух частей. Ранг системы строк матрицы A — это максимальное число линейно независимых строк среди всех строк матрицы A. Ранг системы столбцов матрицы A — это максимальное число линейно независимых столбцов среди столбцов матрицы A. Очень важная теорема линейной алгебры доказывает, что ранг матрицы по столбцам всегда совпадает с её рангом по строкам. Благодаря этому можно говорить просто о ранге матрицы A, не разделяясь на строки или столбцы. Ранг обозначается как rg A. По сути, ранг характеризует количество информации, которое содержится в матрице. Давайте рассмотрим пример, матрица размера 3 на 3, в которой, как мы видим, строки линейно зависимы: чтобы получить вторую, нужно первую умножить на два; чтобы получить третью, нужно первую разделить на два. Кстати, заметьте, при этом столбцы тоже линейно зависимы. Можно получить второй столбец из первого умножением на два, а третий вообще совпадает с первым. Это не случайно. Ранг этой матрицы равен единице, откуда следует, что можно заменить всю эту матрицу на одну строку, потому что остальные строки линейно выражаются через неё. То есть можно заменить матрицу A размера 3 на 3 на матрицу размера 3 на 1 с элементами (1, 2, 1). И при этом мы не потеряем никакой информации. Таким образом, чем меньше ранг, тем сильнее можно сжать матрицу без потерь. Итак, что мы узнали? Определитель — это, по сути, объём параллелепипеда, построенного по векторам, строкам матрицы A, или же по столбцам матрицы A. Определитель не равен нулю, если столбцы линейно независимы, если же они зависимы, то он будет равен нулю. Ранг — это число линейно независимых строк или столбцов в матрице, при этом он характеризует количество информации в этой матрице. В следующем видео мы поговорим о системах линейных уравнений и о том, как устроено их решение. И в этом разговоре нам пригодятся определители и ранги.

[БЕЗ_ЗВУКА] В этом видео мы поговорим о системах линейных уравнений. Как вы помните, это некоторый набор из m уравнений, каждое из которых линейное, то есть представляет собой сумму координат вектора x с некоторыми коэффициентами. И каждое уравнение имеет правую часть b₁, b₂ и т.д. Все это можно записать через матрицы и векторы в виде: матрица A коэффициентов * на вектор неизвестных x = некоторому вектору b, который называется правой частью. Задачей является найти вектор x, удовлетворяющий этому уравнению. Возможно три случая: решений может быть бесконечно много, то есть бесконечно много векторов x удовлетворяют этому уравнению; решение может быть единственным; и наконец, решений может не существовать вообще. Давайте рассмотрим пример. Пусть у нас есть два неизвестных: x и y. Тогда линейная комбинация этих неизвестных, то есть уравнение вида a₁x + a₂y = b будет задавать некоторую прямую на плоскости. Пусть сначала уравнение одно, оно будет задавать прямую. Любая точка, лежащая на этой прямой, будет решением. То есть решений бесконечно много. Добавим еще одно уравнение. Тогда нам нужно будет найти пересечение этих двух прямых, задаваемых первым и вторым уравнением. Это будет одна точка, решение единственное. Наконец, добавим третье уравнение. Будем иметь три прямых, при этом любые две из них пересекаются, но все три не сходятся в одной точке: решения не существует. Как понять, какой из этих случаев имеет место? Для этого нам понадобится ранг. Посчитаем ранг матрицы A и ранг расширенной матрицы A, то есть к матрице A добавим в качестве последнего столбца b — правую часть нашей системы уравнений. Если ранг расширенной матрицы равен рангу исходной матрицы A, то хотя бы одно решение у системы есть. Если же ранг расширенной матрицы больше, то решения не существует, поскольку правая часть не выражается линейно через столбцы матрицы A. Если мы выяснили, что хотя бы одно решение есть, то продолжим. Вычислим ранг матрицы A и сравним его с числом неизвестных, то есть с размером вектора x. Если ранг равен числу неизвестных, то решение единственное. Если же ранг матрицы A меньше числа неизвестных, то решений будет бесконечно много. Что делать дальше? Если решений нет, то и делать нечего. Если решение единственное, то можно воспользоваться любым численным методом решения системы линейных уравнений. Например, в пакете SciPy реализованы некоторые такие методы. Если же решений бесконечно много, то обычно нужно ввести некоторые дополнительные требования: какое именно решение мы хотим найти. Например, мы можем хотеть найти такое решение системы ax = b, которое имеет наименьшую норму среди всех возможных решений. Если матрица A в системе квадратная, то есть удобный способ записать ее решение, записать решение этой системы линейных уравнений. Для этого нам понадобится понятие обратной матрицы. Матрица называется обратной к матрице A, если их произведение равно единичной матрице I, то есть матрице, в которой на диагонали стоят единицы, все остальные элементы равны 0. Обратная матрица обозначается, как A с верхним индексом −1. Обращение определено только для квадратных матриц. У прямоугольных обратных матриц не существует. Есть такая теорема, которая говорит, что обратная матрица у A существует тогда и только тогда, когда определитель A не равен 0. В этом случае найти саму обратную матрицу можно, например, численно, с помощью того же пакета SciPy в Python. Итак, если есть некоторая система линейных уравнений с квадратной матрицей A вида ax = b, то решение x записывается аналитически как обратная матрица к A * b, что сильно упрощает многие выкладки. Итак, что мы узнали. Системы линейных уравнений могут иметь ни одного, одно или бесконечно много решений, при этом выяснить, с каким именно случаем мы имеем дело в конкретной ситуации, можно с помощью понятия ранга матрицы A, расширенной матрицы A и т.д. Решать систему можно численно на компьютере. Если матрица квадратная, то решение можно выразить через обратную матрицу к матрице A в системе. Далее мы с вами поговорим о некоторых специальных классах матриц.

[БЕЗ ЗВУКА] В этом видео мы поговорим об особых типах матриц, которые будут иногда встречаться в наших курсах. Как мы уже знаем, матрица, по сути, задает линейное преобразование из одного векторного пространства в другое. Если матрица квадратная, то можно говорить, что она отображает одно векторное пространство в само себя, то есть переводит векторы этого пространства в какие-то другие векторы этого же пространства. Это можно визуализировать следующим образом. Нарисуем единичный квадратик в осях XY в двумерной плоскости. Тогда можно рисовать, во что переходит этот квадратик после применения преобразования. Например, если мы применяем к нему матрицу (−1, −1, 1, 3), он отражается, поворачивается и растягивается в некоторых направлениях. Первый тип матриц, о которых мы поговорим — это диагональные матрицы, то есть матрицы, у которых на главной диагонали стоят какие-то числа, а вне нее — только нули. Частным случаем диагональных матриц является единичная матрица, у которой на главной диагонали стоят единицы. Она обозначается большой буквой I. По сути, диагональные матрицы растягивают i-тую координату в aii раз. То есть какое число стоит на i-том элементе диагонали, во столько раз и растягивается i-тая координата. Например, матрица, у которой на главной диагонали стоят числа 2 и 1 растягивает первую координату в 2 раза. Следующий тип — это ортогональные матрицы. Так называются матрицы, для которых транспонированная версия является обратной, или, если записать алгебраически, A транспонированное умножить на A равняется единичной, и A умножить на A транспонированное равняется единичной матрице. У ортогональных матриц есть несколько интересных свойств, которые несложно доказать. Например, они сохраняют длины векторов, то есть норма вектора Ax совпадает с нормой вектора x. Также они сохраняют скалярные произведения, то есть скалярное произведение Ax на Az совпадает со скалярным произведением x на z. А раз ортогональные матрицы сохраняют длины и скалярные произведения, то они и сохраняют углы. Можно догадаться, что это матрицы, которые задают преобразования типа поворотов и вращений, которые не меняют длины и углы. Например, матрица с элементами (0,96, 0,28, −0,28, 0,96), которая является ортогональной, поворачивает наш единичный квадратик на примерно 20 градусов. В прошлых видео мы с вами обсуждали определитель. Это довольно сложное математические понятие, которое, например, характеризует объем параллелепипеда, построенного на векторах-строках матрицы. У него есть и другие эквивалентные определения. Еще один способ задать определитель — это сказать, что это характеристика того, во сколько раз увеличится площадь единичного квадрата после применения линейного преобразования, если матрица имеет размер 2 x 2. У ортогональных матриц, следуя из этого определения, определитель всегда равен плюс или минус единице, то есть ортогональные преобразования сохраняют площадь квадрата. Они могут вращать его, отражать, но никак не поменяют его площадь. Наконец, последний специальный класс матриц — это симметричные, то есть матрицы, у которых транспонированная версия совпадает с исходной, то есть A транспонированное равняется A. Это уже более широкий класс матриц, у них меньше интересных свойств, но основное заключается в том, что любую симметричную матрицу A можно представить в виде произведения ортогональной, диагональной и еще одной ортогональной. Это означает, что, по сути, симметричная матрица представляет собой как вращение и отражение, так и растяжение. Например, матрица вида (1, 2, 2, 1), по сути, поворачивает квадрат и растягивает его по обеим координатам. Итак, что мы узнали? Квадратные матрицы переводят элементы векторного пространства в это же пространство, при этом диагональные матрицы только растягивают векторы вдоль осей, ортогональные вращают и отражают их, симметричные представляют собой композицию ортогональных преобразований и диагональных, растягивающих, преобразований. В следующем видео мы с вами поговорим о собственных векторах и собственных значениях.

[ЗАСТАВКА] Из этого видео вы узнаете, что такое собственные векторы и собственные значения, и для чего они нужны. Как мы уже много раз обсуждали, матрица задает линейное преобразование из одного векторного пространства в другое. Если матрица квадратная, то она переводит векторы из некоторого пространства в это же пространство. Например, мы можем взять некоторую картинку и немного повернуть ее вправо. Давайте при этом посмотрим, что происходит с отдельными векторами. Рассмотрим вертикальный красный вектор. После преобразования он немного поворачивается вправо, он меняет свое направление. А вот синий горизонтальный вектор смотрит в ту же сторону, он остается горизонтальным после применения нашего преобразования. По сути, он смотрит именно в ту сторону, в которую и происходит линейная трансформация. Такие векторы, которые не меняют направление движения после преобразования, очень важны и называются собственными векторами. Если говорить формально, собственный вектор — это такой ненулевой вектор x, что A * x = λ * x. λ называется собственным значением. По сути, это уравнение говорит, что вектор x после воздействия на него линейного преобразования A может растянуться или сжаться, но при этом не поменять свое направление. У собственных векторов есть такое свойство: если матрица A имеет размер n * n, то число различных собственных векторов и собственных значений не может превышать n. Давайте в качестве примера рассмотрим матрицу размером 2 x 2 с элементами 2, 1, 1,5 и 2. Если визуализировать ее, то эта матрица, по сути, переводит единичный квадрат в некоторый ромб, растягивая его вправо и вверх по диагонали. Если мы посчитаем собственные векторы и собственные значения этой матрицы, то получим, что первый собственный вектор будет смотреть вправо и вверх по диагонали. По сути, он смотрит ровно в ту сторону, в которую мы растягиваем наш квадрат. При этом собственное значение при нем будет довольно большим: оно равняется 3,2. Второй собственный вектор будет перпендикулярен первому, он будет смотреть влево и вверх. По сути, это тоже важное направление для матрицы: в эту сторону матрица сильнее всего сжимает наш квадрат. Собственное значение при втором собственном векторе будет поменьше: оно равняется 0,77. Зачем вообще нужны собственные векторы и собственные значения? Дело в том, что они будут постоянно всплывать, когда мы будем решать задачу уменьшения матрицы с максимальным сохранением информации в ней, потому что собственные векторы дают наиболее характерные направления движения этой матрицы, наиболее характерные направления изменения векторов. Также мы столкнемся с собственными векторами, когда будем решать задачу понижения числа признаков. В этом случае собственные векторы будут показывать, на какие оси нужно проецировать наши данные чтобы максимально сохранить дисперсию в них, максимально сохранить их разброс. Это называется методом главных компонент. Итак, что мы узнали? Собственные векторы — это направления, в которых матрицы лишь растягивают или сжимают векторы, но при этом не меняют их направления. Собственные векторы показывают наиболее сильные направления изменения, которые задает матрица. Они будут часто встречаться нам, когда мы будем пытаться уменьшать размер матрицы, сохраняя при этом как можно больше информации. На этом мы заканчиваем уроки про линейную алгебру, а уже в следующих курсах будем применять эти знания, чтобы заниматься реальным анализом данных.